<?php
// $Id$

/**
 * @file
 * Core functionality for the Set module.
 */

//TODO: What happens when something is added to or removed from a set?

/**
 * Implementation of hook_theme().
 */
function sets_theme() {
  return array(
    'sets_help' => array(
      'arguments' => array()
    ),
  );
}

/**
 * Builds a formatted list of sets and descriptions.
 *
 * @return An HTML table containing the formatting docs.
 */
function theme_sets_help() {
  $sets = sets_list_sets();

  $headers = array(t('Set'), t('Description'));
  $rows = array();
  foreach ($sets as $set) {
    $rows[] = array(
      '[' . $set['tag'] . ']',
      $set['description'],
    );
  }

  $output = theme('table', $headers, $rows, array('class' => 'description'));
  return $output;
}

function sets_string_get_tags($string) {
   return _sets_string_get_tags($string);
}

function _sets_string_get_tags($string, $offset = 0) {
  $results = array();

  $sets = sets_list_sets();

  $start_pos = strpos($string, '[', $offset);
  $end_pos   = strpos($string, ']', $start_pos);

  if ($start_pos !== FALSE && $end_pos !== FALSE) {
    $results += _sets_string_get_tags($string, $end_pos + 1);
    $tag = substr($string, $start_pos + 1, $end_pos - $start_pos - 1);
    if (isset($sets[$tag])) {
      $results[] = $tag;
    }
  }

  return $results;
}

function sets_string_get($string) {
  return _sets_string_get($string);
}

function _sets_string_get($string, $values = array(), $offset = 0) {
  $results = array();

  $sets = sets_list_sets();

  $start_pos = strpos($string, '[', $offset);
  $end_pos   = strpos($string, ']', $start_pos);

  if ($start_pos !== FALSE && $end_pos !== FALSE) {
    $tag = substr($string, $start_pos + 1, $end_pos - $start_pos - 1);
    if (!isset($sets[$tag])) {
      $result = _sets_string_get($string, $values, $end_pos + 1);
      if ($result === FALSE) {
        $results = FALSE;
      }
      else {
        $results += $result;
      }
    }
    else {
      $provider = sets_get_set_provider($sets[$tag]['provider']);
      $set = call_user_func($provider['set load'], $sets[$tag]);
      foreach ($set as $value) {
        $new_values = $values;
        $new_values[] = array(
          'tag'   => $sets[$tag],
          'value' => $value,
        );
        $new_string = substr($string, 0, $start_pos) . $value . substr($string, $end_pos + 1);
        $result = _sets_string_get($new_string, $new_values, $offset);
        if ($result === FALSE) {
          $results[] = array(
            'string' => $new_string,
            'values' => $new_values,
          );
        }
        else {
          $results += $result;
        }
      }
    }
  }
  else {
    $results = FALSE;
  }

  return $results;
}

/**
 * Iterates over all Set tags in a string recursively and calls the callback for each variant.
 *
 * @param $string
 *   The string to iterate over all Set tags in
 * @param $callback
 *   A function to be called for each variant of $string
 * @param
 *   Any number of additional arguments to be sent to the callback
 */
function sets_string_iterate($string, $callback) {
  $args = func_get_args();
  unset($args[0], $args[1]);
  _sets_string_iterate($string, $callback, $args);
}

/**
 * Iterates over all Set tags in a string recursively and calls the callback for each variant.
 *
 * @param $string
 *   The string to iterate over all Set tags in
 * @param $callback
 *   A function to be called for each variant of $string
 * @param $args
 *   Additional argumenst to be sent to the callback
 * @param $values
 *   An array containing all values of previously replaced tags - used when the original string contains more than one Set tag.
 * @param $offset
 *   Where to start search for Set tags in a string - used when the original string contains more than one Set tag and useful when one of them doesn't exist.
 */
function _sets_string_iterate($string, $callback, $args, $values = array(), $offset = 0) {
  $answers = array();
  $sets = sets_list_sets();

  $start_pos = strpos($string, '[', $offset);
  $end_pos   = strpos($string, ']', $start_pos);

  if ($start_pos !== FALSE && $end_pos !== FALSE) {
    $tag = substr($string, $start_pos + 1, $end_pos - $start_pos - 1);
    if (!isset($sets[$tag])) {
      $answers += _sets_string_iterate($string, $callback, $args, $values, $end_pos + 1);
    }
    else {
      $provider = sets_get_set_provider($sets[$tag]['provider']);
      $set = call_user_func($provider['set load'], $sets[$tag]);
      foreach ($set as $value) {
        $new_values = $values;
        $new_values[] = array(
          'tag'   => $sets[$tag],
          'value' => $value,
        );
        $new_string = substr($string, 0, $start_pos) . $value . substr($string, $end_pos + 1);
        $answers += _sets_string_iterate($new_string, $callback, $args, $new_values, $offset);
      }
    }
  }
  else {
    //Call callback
    array_unshift($args, $string, $values);
    $result = call_user_func_array($callback, $args);
    if ($result !== NULL) {
      $answers[] = $result;
    }
  }
  return $answers;
}

/**
 * Gets the definition of a single provider.
 *
 * @param $set
 *   The name of a provider as a string
 * @return
 *   Array with the provider definition
 */
function sets_get_set_provider($set) {
  ctools_include('plugins');
  return ctools_get_plugins('sets', 'set_provider', $set);
}

/**
 * Gets the definitions of all providers.
 *
 * @return
 *   Array of provider definitions as arrays.
 */
function sets_get_set_providers() {
  ctools_include('plugins');
  return ctools_get_plugins('sets', 'set_provider');
}

/**
 * Lists the available sets.
 *
 * @return
 *   Array with the tag as key and an array with properties as the value.
 */
function sets_list_sets() {
  static $sets;

  if (!isset($sets)) {
    $sets = array();

    $providers = sets_get_set_providers();
    foreach ($providers as $provider_name => $provider) {
      $tmp = call_user_func($provider['sets list'], $context);
      foreach ($tmp as $key => $value) {
        if (is_array($value)) {
          $sets[$key] = $value + array(
            'tag'      => $key,
            'provider' => $provider_name,
          );
        }
        else {
          $sets[$value] = array(
            'tag'      => $value,
            'provider' => $provider_name,
          );
        }
      }
    }
  }

  return $sets;
}

/**
 * Function to clean a tag to only use a-z, 0-9 as well as - and _.
 */
function sets_clean_tag($tag) {
  return preg_replace('/\W/', '-', strtolower($tag));
}

/**
 * Implementation of hook_ctools_plugin_TYPE().
 */
function sets_ctools_plugin_set_provider() {
  //TODO: Make it possible to add cache here
  return array(
    'hook' => 'set_provider',
  );
}

/**
 * Implementation of hook_ctools_plugin_directory().
 */
function sets_ctools_plugin_directory($module, $plugin) {
  if ($module == 'sets' && $plugin == 'set_provider') {
    return 'plugins';
  }
}